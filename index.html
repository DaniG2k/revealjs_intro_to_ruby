<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Learn Ruby</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Section -->
				<section>
					<h1>
						Welcome to Learn Ruby!
					</h1>
					<img src="../svg/ruby_logo.svg" srcset="../svg/ruby_logo.svg" alt="Ruby logo" class="no_border no_box_shadow">
				</section>
				<!-- Section -->
				<section data-transition="zoom">
					<h2>What is Ruby?</h2>
					<p>
						Ruby is a <span class="fragment fade-in"><strong>dynamic</strong>, </span>
						<span class="fragment fade-in"><strong>reflective</strong>, </span>
						<span class="fragment fade-in"><strong>object-oriented</strong>, general-purpose programming language.</span></p>
					<p class="fragment fade-in">It was designed and developed in the mid '90s by Yukihiro "Matz" Matsumoto in Japan.</p>
					<p class="fragment fade-in">It became largely popular due to the web framework, Ruby on Rails, but Ruby can be used for essentially any purpose</p>
				</section>
				<section
					data-background-image="../images/Yukihiro_Matsumoto.jpg"
					data-background-size="contain"
					data-transition="slide-in fade-out">
					<blockquote>
						<p>
							Throughout the development of the Ruby language, I've focused my energies on making programming faster and easier.
						</p>
						<p>
							All features in Ruby, including object-oriented features, are designed to work as ordinary programmers (e.g., me) expect
							them to work. Most programmers feel it is elegant, easy to use, and a pleasure to program.
						</p>
						<p>
							<strong>Ruby is designed to make programmers happy.</strong> - Yukihiro Matsumoto
						</p>
					</blockquote>
				</section>
				<!-- Section -->
				<section>
					<h2>Dynamic</h2>
					<p>A high-level programming language which, at <strong>runtime</strong>, executes many common programming behaviors that static programming languages perform during <strong>compilation</strong>.</p>
					<p>Unlike compiled languages like C or Java, Ruby code evaluates at <strong>runtime</strong>.</p>
				</section>
				<section>
					<h2>Dynamically typed</h2>
					<p>Varialbes can receive different values at runtime and their type is defined at run time.</p>
					<pre>
						<code class="java" data-trim data-noescape>
							// Java
							String str = "Hello";  //variable str statically typed as string
							str = 5;               //would throw an error since str is supposed to be a string only

							# Ruby
							str = "Hello" # variable str is linked to a string value
							str = 5       # now it is linked to an integer value; perfectly OK
						</code>
					</pre>
				</section>
				<!-- Section -->
				<section>
					<h2>Reflective</h2>
					<p>Reflection is the ability of a computer program to <strong>examine</strong>, <strong>introspect</strong>, and <strong>modify</strong> its own structure and behavior at runtime.</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							34.is_a?(Numeric)
							=> true
							[1, 2, 3].class
							=> Array
							"hello".methods
							=> [:include?, :count, :sum, :next, :replace,
							:downcase, :upcase, :empty?, :eql?,
							:capitalize ... ]
						</code>
					</pre>
				</section>
				<!-- Section -->
				<section data-transition="slide-in fade-out">
					<h2>Object Oriented</h2>
					<p>
						Everything's an object!
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							"Ruby intro meetup!".upcase

							3.times do
							  puts "Hello world :)"
							end
						</code>
					</pre>
				</section>
				<!-- Section -->
				<section>
					<h2>Ruby as a calculator</h2>
					<pre>
						<code class="ruby" data-trim data-noescape>
							1 + 2
							=> 3
							4 - 3
							=> 1
							3 * 3
							=> 9
							3 / 2
							=> 1 # whoa what??
						</code>
					</pre>
				</section>
				<section data-transition="zoom">
					<h2>Numbers in Ruby</h2>
					<p>An integer is a whole number, like 1, 2, -5, etc. When you operate using only integers, <strong>Ruby will give you an Integer answer</strong>.</p>
					<p>
						3 / 2 is 1.5, but that is not an integer, so Ruby gives you 1 instead. A float is a number with decimal places, like 3.14, 1.5, 3.0, etc. When you operate with Floats <strong>Ruby gives you a Float answer</strong>.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							3.0 / 2.0
							=> 1.5 # Much better :)
						</code>
					</pre>
				</section>
				<section>
					<h2>Number operators</h2>
					<pre>
						<code class="ruby" data-trim data-noescape>
							1 + 2   # Addition
							4 - 3   # Subtraction
							3 * 3   # Multiplication
							4 / 2   # Division
							3 ** 2  # Exponentiation
							5.1 % 2 # Remainder (modulo operator)
						</code>
					</pre>
				</section>
				<section data-transition="slide-in fade-out">
					<h2>Massive numbers</h2>
					<p>Ruby is good at dealing with very large and very small numbers. Suppose that you want to store the number 192349562563447. That's very hard to read.</p>
					<p>So, in English, you would normally write it as "192,349,562,563,447". Ruby uses something similar, using <strong>underscores</strong></p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							192_349_562_563_447
							=> 192349562563447
						</code>
					</pre>
				</section>
				<section>
					<h2>Tiny numbers</h2>
					<p>You can do the same for very small numbers.</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							0.000_000_000_000_321
							=> 3.21e-13 # Returned value is in scientific notation
						</code>
					</pre>
					<p>Ruby gives you the option to write small numbers with <strong>underscores</strong> or in <strong>scientific notation</strong>.</p>
				</section>
				<section>
					<h2>Try it out</h2>
					<ol>
						<li>
							What happens when you combine floats and integers?
						</li>

						<li>
							How many hours are in a year?
						</li>
						<li>
							How many seconds old are you?
						</li>
					</ol>
				</section>

				<section data-transition="zoom">
					<h2>Strings</h2>
					<p>String are sequences of characters which are "strung" together.</p>
					<p>Here are some things you can do with strings:</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							"Hello " + "World"
							=> "Hello World"
							"Na" * 16 + " Batman"
							=> "NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNa Batman"
							"1" + "2"
							=> "12"
							"1" * 2
							=> "11"
						</code>
					</pre>
				</section>
				<section data-transition="slide-in fade-out">
					<h2>More things you can do with text</h2>
					<p>
						Since strings are objects in Ruby, you can call <strong>methods</strong> on them. More on methods later.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							"korea".capitalize
							=> "Korea"
							"helo".next
							=> "help"
							"john".upcase
							=> "JOHN"
							"JOHN".downcase
							=> "john"
							"Why Am I tYping LiKe thIS?".swapcase
							=> "wHY aM i TyPING lIkE THis?"
						</code>
					</pre>
					<p>
						What do you expect this will do:
						<strong>'hello'.length + 'world'.length</strong>
					</p>
				</section>
				<section>
					<h2>Interpolation</h2>
					<p>
						Ruby allows you to interpolate within strings, on the fly! Interpolation means the insertion of something of a different nature into something else.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							"I ate #{40 / 3 - 11} meals today"
							=> "I ate 2 meals today"
							#
							# or
							#
							wallet_state = 'empty'
							"My current wallet state is: #{wallet_state}"
							=> "My current wallet state is: empty"
						</code>
					</pre>
				</section>
				<section data-background-image="../images/empty_wallet.jpg"
					data-background-size="contain"
					data-transition="slide-in fade-out">
				</section>
				<section data-transition="zoom">
					<h2>Symbols</h2>
					<p>
						In Ruby, a string is mutable, whereas a symbol is immutable. That means that only one copy of a symbol needs to be created.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							x = :my_sym # :my_str will only be created once,
							y = :my_sym # and x and y point to the same area of memory.

							x = "my_str" # a string containing my_str will be created twice,
							y = "my_str" # and x and y will point to different instances.
						</code>
					</pre>
				</section>
				<section data-transition="zoom">
					<h2>Symbol / String conversion</h2>
					<p>
						Despite being different, you can <strong>cast</strong> a symbol to a string and vice-versa. You can do this using the <strong>.to_sym</strong> and <strong>.to_s</strong> methods.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							'my_symbol'.to_sym
							=> :my_symbol
							:my_string.to_s
							=> 'my_string'
						</code>
					</pre>
				</section>
				<section>
					<h2>Variables</h2>
					<p>
						A variable is a name that Ruby associates with a particular object. It is a way to store information.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							city = "Busan"
						</code>
					</pre>
          <p>
						Ruby associates the string "Busan" with the name (variable) city.
					</p>
				</section>
				<section>
					<h2>Variable benefits</h2>
					<p>
						The good thing about variables is that it allows you to keep track of information more easily.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							num1 = 2 + 4 + 6 + 8
							num1 = num1 / 5
							num2 = 8 * 3
							num2 = num2 - num1
							=> 20
						</code>
					</pre>
				</section>
				<section>
					<h2>Variable assignment shortcuts</h2>
					<pre>
						<code class="ruby" data-trim data-noescape>
							var += 2  # add 2 to var
							var -= 3  # subtract 3 from var
							var *= 6  # multiply var by 6
							var /= 2  # divide var by 2
							var **=3  # cube var
							var %= 4  # var modulo 4
						</code>
					</pre>
				</section>
				<section data-transition="slide-in fade-out">
					<h2>Constants</h2>
					<p>Constants are like variables, except that you are tellig Ruby that their value is supposed to remain fixed.</p>
					<p>If you try to change the value of a constant, Ruby will give you a warning.</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							PI = 3.14159
							PI += 2
							(irb):2: warning: already initialized constant PI
							(irb):1: warning: previous definition of PI was here
							# Ruby complains about PI already being initialized because
							# this constant exists as Math::PI
						</code>
					</pre>
				</section>
				<section>
					<h2>Good programming practices</h2>
					<ol>
						<li>
							Pick good variable names
						</li>
						<ul>
							<li>
								'age' or 'vehicle', not 'a' or 'v'
							</li>
						</ul>
						<li>Be descriptive</li>
						<ul>
							<li>
								'student_age' or 'message_request'
							</li>
						</ul>
						<li>
							Whenever you have a value that should not change, always make it a constant.
						</li>
						<ul>
							<li>
								'PI' or 'DELTA'
							</li>
						</ul>
					</ol>
				</section>
				<section>
					<h2>Loops</h2>
					<p>
						The most commonly used loop in Ruby is the <strong>each</strong> loop.
						It allows you to iterate over many object types, such as a <strong>Range</strong>.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							(0..10).each do |num|
							  puts "The number is now #{num}"
							end
						</code>
					</pre>
					<p>Notice how the range starts at 0 and ends at 10 (inclusive). If you want it to not be inclusive, add another period: </strong>(0...10)</strong></p>
				</section>
				<section data-transition="zoom">
					<h2>More loops</h2>
					<p>
						Ruby is full of descriptive loop methods you can use. Here's another example:
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							loop do
							  # this goes on infinitely until break is called
							  break
							end
							# or
							5.times do
							  puts 'Ruby Meetup!'
							end
							# or
							10.downto(1) do |num|
							  puts "8 x #{num} = #{8 * num}"
							end
							# or
							10.upto(20) do |num|
							  puts "The square root of #{num} is #{Math.sqrt(num)}"
							end
						</code>
					</pre>
				</section>
				<section>
					<h2>Ranges</h2>
					<p>
						You can easily make integer and character ranges in Ruby! Here's how.
						(Note: the method .to_a means 'to array')
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							(0..5).to_a
							=> [0, 1, 2, 3, 4, 5]
							(0...5).to_a
							=> [0, 1, 2, 3, 4]
							('A'..'I').to_a
							=> ["A", "B", "C", "D", "E", "F", "G", "H", "I"]
							('a'..'i').to_a
							=> ["a", "b", "c", "d", "e", "f", "g", "h", "i"]
						</code>
					</pre>
				</section>
				<section>
					<h2>Booleans</h2>
					<p>
						A boolean is a data type that returns either true or false.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							true
							=> true
							false
							=> false
							!true # ! is the negation operator
							=> false
							!false
							= true
						</code>
					</pre>
				</section>
				<section>
					<h2>Boolean operators</h2>
					<p>
						Here is a list of some of the most common boolean operators
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							&&  # AND (both A and B are true)
							||  # OR (either A or B is true)
							==  # equal to
							!=  # not equal to
							>   # greater than
							<   # less than
							>=  # greater than or equal to
							<=  # less than or equal to
						</code>
					</pre>
				</section>
				<section>
					<h2>Arrays</h2>
					<p>
						Arrays are ordered, integer-indexed collections of <strong>any object</strong>.
						Array indexing starts at <strong>0</strong>.
						A negative index is assumed to be relative to the end of the array — that is, an index of -1 indicates the last element of the array, -2 is the next to last element in the array, and so on.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							arr = [1, 2, 3, 4, 5, 6]
							arr[2]    #=> 3
							arr[100]  #=> nil
							arr[-3]   #=> 4
							arr[2, 3] #=> [3, 4, 5] take three from pos 2
							arr[1..4] #=> [2, 3, 4, 5] take from pos 1 to 4
							arr[1..-3] #=> [2, 3, 4] take from pos 1 to -3
							arr.first #=> 1
							arr.last  #=> 6
							arr.take(3) #=> [1, 2, 3]
						</code>
					</pre>
				</section>
				<section data-transition="slide-in fade-out">
					<h2>Hashes</h2>
					<p>
						A Hash is a dictionary-like collection of unique keys and their values.
						They are similar to Arrays, but where an Array uses integers as its index, a Hash allows you to use any object type.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							grades = { "Jane Doe" => 10, "Jim Doe" => 6 }
							options = { :font_size => 10, :font_family => "Arial" } # These two are
							options = { font_size: 10, font_family: "Arial" }       # exactly the same!
							options[:font_size]
							=> 10
							options.keys
							=> [:font_size, :font_family]
							options.values
							=> [10, "Arial"]
						</code>
					</pre>
				</section>
				<section data-transition="zoom">
					<h2>Getting user input</h2>
					<p>
						Let's write a simple program now that takes user input and outputs the person's name and year of birth.
						We will use the 'gets' command (similar to 'puts') to get user input.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							puts 'What is your name?'
							name = gets.chomp # get user input and 'chomp' the newline off
							puts 'How old are you?'
							age = gets.chomp.to_i # get user input, chomp and convert to integer
							current_year = Time.now.year

							puts "#{name} was born in #{current_year - age}"
						</code>
					</pre>
				</section>
				<section>
					<h2>More user input</h2>
					<p>
						Now let's write a mini program to compute the factorial (계승) of a given number.
						The factorial is the product of all positive integers less than or equal to n.
						For example: 5! = 5 x 4 x 3 x 2 x 1 = 120
					</p>
					<p>
						Try the following with <strong>40</strong>
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
		puts 'Type a number:'
		number = gets.chomp.to_i
		factorial = 1
		number.downto(1) do |n|
		  factorial *= n
		end
		puts "The factorial of #{number} is #{factorial}"
						</code>
					</pre>
				</section>
				<section
					data-background-image="../images/mind_blown.gif"
					data-background-size="contain"
					data-transition="slide-in fade-out">
				</section>
				<section>
					<h2>Conditionals</h2>
					<p>
						Conditionals such as <strong>if</strong> statements allow you to take different actions depending on which conditions are met.
						For example
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							if city == 'Seoul'
							  puts "Welcome to the capital"
							else
							  puts "You're in South Korea"
							end
						</code>
					</pre>
				</section>
				<section>
					<h2>Same-line conditionals</h2>
					<p>
						In Ruby it is possible to write conditional statements on the same line (no need for an 'end' keyword!)
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							city = 'SEOUL'
							puts "Welcome to the capital!" if city.downcase == 'seoul'
							=> "Welcome to the capital!"
						</code>
					</pre>
				</section>
				<section>
					<h2>Ternary operator</h2>
					<p>
						In addition to the previous same-line conditional, it is possible to use the <strong>ternary operator</strong>
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							cold = true
							cold ? "It's freeeezing ☃️" : "Not bad 🙃"
							=> "It's freeeezing ☃️"
						</code>
					</pre>
				</section>
				<section>
					<h2>Try it out</h2>
					<p>
						Write a small program that goes over this hash and prints out the value if it contains the word 'koala'.
						To check for string inclusion use the method string1<strong>.include?(string2)</strong>
						Note: pay attention to upper and lower-case letters!
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							animals = {
							  dogs: 'German Shepherds and Golden Retrievers',
							  pets: 'Koalas and lizards',
							  cats: 'Munchkins and Siamese'
							}
						</code>
					</pre>
				</section>
				<section data-background-image="../images/koala.jpg"
					data-background-repeat="no-repeat"
					data-background-size="contain"
					data-transition="slide-in fade-out">
				</section>
				<section>
					<h2>Adding conditions</h2>
					<p>
						You can add conditions with 'elsif' statements.
						When writing conditions, it is important to pay attention to the order of operations.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							age = 21
							if age > 5
							  puts "Older than 5" # This will get printed!
							elsif age > 10
							  puts "Older than 10"
							elsif age > 20
							  puts "Older than 20"
							end
						</code>
					</pre>
				</section>
				<section data-transition="zoom">
					<h2>Case statements</h2>
					<p>
						A handy alternative to if, elsif, else statements are <strong>case</strong> statements
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							dog = 'adult'
							noise = 'bark!'

							case dog
							when 'puppy'
							  puts noise
							when 'adult'
							  puts noise.upcase
							end
						</code>
					</pre>
				</section>
				<section>
					<h2>Methods</h2>
					<p>In Ruby, the word <strong>method</strong> is used but the same construct may be called <strong>function</strong> in other programming languages.</p>
					<p>
						Methods are like recipies. They are used to bundle one or more repeatable statements into a single unit.
						Method names should begin with a lowercase letter. If you begin a method name with an uppercase letter, Ruby might think that it is a constant and hence can parse the call incorrectly.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							def my_method()
							  # do cool things
							end
						</code>
					</pre>
				</section>

				<section>
					<h2>Calling a method</h2>
					<p>
						You can call a method simply by typing out its name. The last instruction in the method is the result that will be returned.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							def factorial(input_number)
							  fac = 1
							  input_number.downto(1) do |i|
							    fac *= i
							  end
							  fac # This line can also be written as 'return fac'
							end
							factorial 5
							=> 120
						</code>
					</pre>
				</section>

				<section data-transition="zoom">
					<h2>Syntactic sugar</h2>
					<p>
						Unlike some other programming languages, Ruby allows you to omit parentheses in method definitions.
					</p>
					<p>This is called <strong>syntactic sugar</strong>.</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							def my_method(param1, param2)
							  # do stuff
							end
							# is the same as
							def my_method param1, param2
							  # do stuff
							end
						</code>
					</pre>
				</section>

				<section data-transition="zoom">
					<h2>More sugar - blocks</h2>
					<p>
						A block is basically just code that you put inside do and end. That's it.
						You can write the block in two ways, and both versions will do the exact same thing so it's up to you which one you choose.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							[1, 2, 3].each do |n|
							  puts "Number #{n}"
							end
							#
							# is the same as
							#
							[1, 2, 3].each {|n| puts "Number #{n}"}
						</code>
					</pre>
				</section>

				<section data-transition="slide-in fade-out">
					<h2>Classes</h2>
					<p>
						An object-oriented program involves classes and objects. A class is the blueprint from which individual objects are created.
						In object-oriented terms, we say that your bicycle is an instance of the class of objects known as bicycles.
					</p>
					<p>
						A class in Ruby always starts with the keyword class followed by the name of the class. The name should always be in initial capitals.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							class Car
							  # do stuff
							end
						</code>
					</pre>
				</section>
				<section>
					<h2>Initializing a class</h2>
					<p>
						Classes can be initialized with the '.new' method. In order to be initialized, they need an 'initialize' method.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							class Car
							  def initialize(color, type)
							    @color = color # These two variables with an '@'
							    @type = type   # are called instance variables.
							                   # They stay around as long as the Car object stays alive.
							  end
							end

							my_car = Car.new('red', 'ferrari')
						</code>
					</pre>
				</section>
				<section data-transition="slide-in fade-out">
					<h2>Getters and setters</h2>
					<p>
						In some programming languages, you need to explicitly define a class' getter and setter methods. Ruby has helpers that do this for you.
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							class Car
							  # The three helper methods:
							  # attr_reader, attr_writer, attr_accessor
							  attr_reader :type
							  attr_accessor :color

							  def initialize(color, type)
							    @color = color # These two variables with an '@'
							    @type = type   # are called instance variables.
							                   # They stay around as long as the Car object stays alive.
							  end

							  # Without the getter and setter methods above
							  # we'd have had to write out
							  # def type
							  #   @type
							  # end
							  #
							  # def color=(color)
							  #   @color = color
							  # end
							  #
							  # def color
							  #   color
							  # end
							end

							my_car = Car.new('red', 'ferrari')
							my_car.type
							my_car.color = 'blue'
							my_car.color
						</code>
					</pre>
				</section>
				<section>
					<h2>Class inheritance</h2>
					<p>
						A class can inherit behavior from another class with the '<' directive:
					</p>
					<pre>
						<code class="ruby" data-trim data-noescape>
							class Car
							  attr_reader :color

							  def initialize(color)
							    @color = color
							    @kmh_to_mph_ratio = 1.609344
							  end
							end

							class Ferrari < Car
							  def max_speed_kmh
							    348
							  end

							  def max_speed_mph
							    max_speed_kmh / @kmh_to_mph_ratio
							  end
							end

							class Lamborghini < Car
						    def max_speed_kmh
							    350
							  end

							  def max_speed_mph
							    max_speed_kmh / @kmh_to_mph_ratio
							  end
							end

							my_car = Ferrari.new 'red'
							my_car.color
							=> "red"
							my_car.max_speed_mph
							=> 216.2371748985922
						</code>
					</pre>
				</section>
				<!-- <section>
					<h2>Dynamic dispatch</h2>
					<p>
						The process of selecting which implementation of a polymorphic operation (method or function) to call at run time.
					</p>
				</section> -->
				<section>
					<h2>Congratulations</h2>
					<p>
						You now have all the tools you need to create a fully-fledged program! 😀
					</p>
				</section>
				<section data-background-image="../images/thumbs_up.gif"
					data-background-size="contain"
					data-transition="slide-in fade-out">
				</section>
				<section>
					<h2>Putting it all together</h2>
					<p>Let's get started on writing an address book!</p>
					<p>
						Create three empty files:
						<ul>
							<li>phone_number.rb</li>
							<li>contact.rb</li>
							<li>address.rb</li>
							<li>address_book.rb</li>
						</ul>
					</p>
					<p>
						https://goo.gl/29EE9e
					</p>
				</section>
				<section>
					<h2>phone_number.rb</h2>
					<pre class="ruby" data-trim data-noescape>
						<code>
class PhoneNumber
  attr_accessor :kind, :number

  def to_s
    "#{kind}: #{number}"
  end
end
						</code>
					</pre>
				</section>
				<section>
					<h2>address.rb</h2>
					<pre>
						<code class="ruby" data-trim data-noescape>
class Address
  attr_accessor :kind, :street_1, :street_2, :city, :state, :postal_code

  def to_s(format = 'short')
    address = "#{kind}: "
    if format == 'short'
      address += street_1
      address += " #{street_2}" if street_2
      address += ", #{city}, #{state} #{postal_code}"
    elsif format == 'long'
      address += street_1 + "\n"
      address += street_2 + "\n" if street_2
      address += "#{city}, #{state} #{postal_code}"
    end
  end
end</code>
					</pre>
				</section>
				<section>
					<h2>contact.rb</h2>
					<pre>
						<code class="ruby" data-trim data-noescape>
require "./phone_number"
require "./address"

class Contact
  attr_writer :first_name, :middle_name, :last_name
  attr_reader :phone_numbers, :addresses

  def initialize
    @phone_numbers = []
    @addresses = []
  end

  def add_phone_number(kind, number)
    phone_number = PhoneNumber.new
    phone_number.kind = kind
    phone_number.number = number
    phone_numbers.push(phone_number)
  end

  def add_address(kind, street1, street2, city, state, postal_code)
    address = Address.new
    address.kind = kind
    address.street_1 = street1
    address.street_2 = street2
    address.city = city
    address.state = state
    address.postal_code = postal_code
    addresses.push(address)
  end

  def first_name
    @first_name
  end

  def middle_name
    @middle_name
  end

  def last_name
    @last_name
  end

  def first_last
    first_name + " " + last_name
  end

  def last_first
    last_first = last_name
    last_first += ", "
    last_first += first_name
    if !@middle_name.nil?
      last_first += " "
      last_first += middle_name.slice(0, 1)
      last_first += "."
    end
    last_first
  end

  def full_name
    full_name = first_name
    if !@middle_name.nil?
      full_name += " "
      full_name += middle_name
    end
    full_name += ' '
    full_name += last_name
    full_name
  end

  def to_s(format = 'full_name')
    case format
    when 'full_name'
      full_name
    when 'last_first'
      last_first
    when 'first'
      first_name
    when 'last'
      last_name
    else
      first_last
    end
  end

  def print_phone_numbers
    puts "Phone Numbers"
    phone_numbers.each { |phone_number| puts phone_number }
  end

  def print_addresses
    puts "Addresses"
    addresses.each { |address| puts address.to_s('short') }
  end
end</code>
					</pre>
				</section>
				<section>
					<h2>address_book.rb</h2>
					<pre>
						<code class="ruby" data-trim data-noescape>
require "./contact"
require "yaml"

class AddressBook
  attr_reader :contacts

  def initialize
    @contacts = []
    open()
  end

  def run
    loop do
      puts "Address Book"
      puts "a: Add New Contact"
      puts "s: Search Contacts"
      puts "p: Print Address Book"
      puts "e: Exit"
      print "Enter your choice: "
      input = gets.chomp.downcase
      if input == 'e'
        save()
        break
      elsif input == 'p'
        print_contact_list
      elsif input == 'a'
        add_contact
      elsif input == 's'
        print "Search term: "
        search = gets.chomp
        find_by_name(search)
        find_by_phone_number(search)
        find_by_address(search)
      end
    end
  end

  def open
    if File.exist?("contacts.yml")
      @contacts = YAML.load_file("contacts.yml")
    end
  end

  def save
    File.open("contacts.yml", "w") do |file|
      file.write(contacts.to_yaml)
    end
  end

  def add_contact
    contact = Contact.new
    print "First name: "
    contact.first_name = gets.chomp
    print "Middle name: "
    contact.middle_name = gets.chomp
    print "Last name: "
    contact.last_name = gets.chomp
    contacts.push(contact)

    loop do
      puts "Add a phone number or address? "
      puts "p: Add phone number"
      puts "a: Add address"
      puts "Enter any other key to go back"
      response = gets.chomp.downcase
      if response == 'p'
        phone = PhoneNumber.new
        print "Phone number type (home, work, etc): "
        phone.kind = gets.chomp
        print "Number: "
        phone.number = gets.chomp
        contact.phone_numbers.push(phone)
      elsif response == 'a'
        address = Address.new
        print "Address Kind (Home, Work, etc): "
        address.kind = gets.chomp
        print "Address line 1: "
        address.street_1 = gets.chomp
        print "Address line 2: "
        address.street_2 = gets.chomp
        print "City: "
        address.city = gets.chomp
        print "State: "
        address.state = gets.chomp
        print "Postal Code: "
        address.postal_code = gets.chomp
        contact.addresses.push(address)
      else
        print "\n"
        break
      end
    end
  end

  def print_contact_list
    puts "Contact List:" + "\n"
    contacts.each do |contact|
      puts contact.to_s('last_first')
    end
  end

  def find_by_name(name)
    results = []
    search = name.downcase
    contacts.each do |contact|
      results.push(contact) if contact.full_name.downcase.include?(search)
    end
    print_results("Name search results (#{search}):", results)
  end

  def find_by_phone_number(number)
    results = []
    search = number.gsub("-", "")
    contacts.each do |contact|
      contact.phone_numbers.each do |phone_number|
        if phone_number.number.gsub("-", "").include?(search)
          results.push(contact) unless results.include?(contact)
        end
      end
    end
    print_results("Phone search results (#{search}):", results)
  end

  def find_by_address(query)
    results = []
    search = query.downcase
    contacts.each do |contact|
      contact.addresses.each do |address|
        if address.to_s('long').downcase.include?(search)
          results.push(contact) unless results.include?(contact)
        end
      end
    end
    print_results("Address search results (#{search}):", results)
  end

  def print_results(search_label, results)
    puts search_label
    results.each do |contact|
      puts "\n" + contact.to_s("full_name")
      contact.print_phone_numbers
      contact.print_addresses
    end
  end
end

address_book = AddressBook.new
address_book.run
</code>
					</pre>
				</section>
				<section>
					<h2>Thank you!</h2>
					<img width="50%" src="../svg/ruby_end_logo.svg" srcset="../svg/ruby_end_logo.svg" alt="Ruby end logo" class="no_border no_box_shadow">
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				slideNumber: 'c/t',
				width: 1024,
				height: 768,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
